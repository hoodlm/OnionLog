using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Collections.Generic;

/**
 *  OnionLogger is a stack-based logging tool. Most logging utilities generate
 *  a monolithic block of logging statements. OnionLogger allows you to organize
 *  your logging statements hierarchally by pushing and popping layers on a
 *  stack. Each time you push a layer, your log is indented.
 * 
 *  Individual OnionLogger instances are not thread-safe. If you require logging
 *  for multiple threads, you must create a new OnionLogger for each thread and
 *  write to separate files.
 * 
 *  This tool is licensed under the MIT License, available here:
 *  http://opensource.org/licenses/MIT
 * 
 *  (C) 2014 Logan M Hood
 */
public class OnionLogger {
    
    /** A shared OnionLogger instance that can be used between multiple classes.
     *  You will have to instantiate it first.
     * 
     *  This is purely for convenience - under normal usage, it is probably a
     *  better practice to create your own wrapper class to hold a shared
     *  OnionLogger instance.
     * 
     *  In particular, this should not be used in Unity because static objects
     *  are not necessarily destructed when stopping play - you may have to
     *  actually close the Unity Editor to flush everything from the file.
     */
    public static OnionLogger globalLog;
    
    /**
     *  The set of available LoggingLevels. In increasing order of importance,
     *  they are: TRACE< DEBUG < INFO < WARN < ERROR < FATAL
     * 
     *  By setting the LoggingLevel of an OnionLogger, lower level log messages
     *  are suppressed. For example, a logger set to WARN will only log messages
     *  marked WARN, ERROR, or FATAL.
     * 
     *  A logger can also be set to OFF To suppress all logging messages.
     */
    public enum LoggingLevels : byte {
        TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF};
    
    /// The logging level of an OnionLogger instance.
    public LoggingLevels LoggingLevel;

	/** How often to flush output to the stream (i.e. how often to write to the
     *  file). This can be set higher to decrease the frequency of disk access,
     *  since the underlying StreamWriter.flush() is a blocking method.
     * 
     *  From my tests, high frequency writes tend to perform best with a value
     *  of around 50-100 milliseconds. This was tested on a mobile HDD, so
     *  different values may work better for SSDs or other storage media.
	 * 
	 *	If this is set to 0, the logger will flush after every write.
	 *	Default value is 100 milliseconds.
	 */ 
	public long FlushFrequencyInMilliseconds = 100;

	/**	Used in conjunction with FlushFrequencyInMilliseconds to determine if 
     *  the writer should flush.
     */
	private long timeOfLastFlush = 0;

	private static readonly DateTime BEGINNING_OF_TIME = new DateTime(1970,1,1);

    /// The StreamWriter used to write to the logfile.
    private readonly StreamWriter writer;

    /** 
     *  Defines the character used for indentation. Generally either a space or
     *  a tab.
     */
    private readonly char indentChar;

    /// The number of indentChar to use for each indentation. By default, 2.
    private readonly uint indentSize;
    
    /// The string to use for each indentation.
    /// (i.e. "indentChar" repeated "indentSize" times)
    private readonly string indentationString;

    /// The current stack of LogLayers.
    private readonly Stack<LogLayer> stack;

    /** 
     *  Create an instance of the OnionLogger class, with default settings:
     *  - filename is generated by the DefaultLogFilename method
     *  - indentChar is a space
     *  - indentSize is 2
     *  - loggingLevel is DEBUG
     */
    public OnionLogger()
    {
        string filepath = "./"+DefaultLogFilename();
        this.LoggingLevel = LoggingLevels.DEBUG;
        this.indentChar = ' ';
        this.indentSize = 2;
        StringBuilder sb = new StringBuilder();
        for (uint i = 0; i < indentSize; ++i) {
            sb.Append(indentChar);
        }
        indentationString = sb.ToString();
        
        stack = new Stack<LogLayer>();
        writer = new StreamWriter(filepath);
    }

    /** 
     *  Initializes a new instance of the OnionLogger class.
     *  Uses default settings for other parameters:
     *  - indentChar is a space.
     *  - indentSize is 2.
     *  - loggingLevel is DEBUG
     *  @param filepath     Path to the logfile.
     */
    public OnionLogger(string filepath)
    {
        this.LoggingLevel = LoggingLevels.DEBUG;
        this.indentChar = ' ';
        this.indentSize = 2;
        StringBuilder sb = new StringBuilder();
        for (uint i = 0; i < indentSize; ++i) {
            sb.Append(indentChar);
        }
        indentationString = sb.ToString();

        stack = new Stack<LogLayer>();
        writer = new StreamWriter(filepath);
    }
    
    /** 
     *  Initializes a new instance of the OnionLogger class.
     *  @param filepath     Path to the logfile.
     *  @param indentChar   Character used for indentation.
     *  @param indentSize   The number of times to repeat indentChar for each
     *                      indentation.
     *  @param loggingLevel The lowest level messages to log, where:
     *                      TRACE < DEBUG < INFO < WARN < ERROR < FATAL
     */
    public OnionLogger(string filepath, 
                       char indentChar, 
                       uint indentSize,
                       LoggingLevels loggingLevel)
    {
        this.indentChar = indentChar;
        this.indentSize = indentSize;
        this.LoggingLevel = loggingLevel;
        
        StringBuilder indentationSb = new StringBuilder();
        for (uint i = 0; i < indentSize; ++i) {
            indentationSb.Append(indentChar);
        }
        this.indentationString = indentationSb.ToString();
        
        stack = new Stack<LogLayer>();
        writer = new StreamWriter(filepath);
    }
    
    /**
     *  Log a line with the TRACE logging level.
     */
    public void LogTrace(string message) {
        LogWithLevel(LoggingLevels.TRACE, message);
    }
    
    /**
     *  Log a line with the INFO logging level.
     */
    public void LogInfo(string message) {
        LogWithLevel(LoggingLevels.INFO, message);
    }
    
    /**
     *  Log a line with the DEBUG logging level.
     */
    public void LogDebug(string message)
    {
        LogWithLevel(LoggingLevels.DEBUG, message);
    }
    
    /**
     *  Log a line with the WARN logging level.
     */
    public void LogWarn(string message) {
        LogWithLevel(LoggingLevels.WARN, message);
    }
    
    /**
     *  Log a line with the ERROR logging level.
     */
    public void LogError(string message) {
        LogWithLevel(LoggingLevels.ERROR, message);
    }
    
    /**
     *  Log a line with the FATAL logging level.
     */
    public void LogFatal(string message) {
        LogWithLevel(LoggingLevels.FATAL, message);
    }
    
    /**
     *  Writes a line to the log with the following format:
     * 
     *  LEVEL <indent> MESSAGE
     * 
     *  where the spacing between LEVEL and MESSAGE is the indentation level.
     *  If the OnionLogger has a higher logging level that this message,
     *  the message is discarded.
     */
    private void LogWithLevel(LoggingLevels level, string message)
    {
        if (this.LoggingLevel > level) {
            return;
        }
        
        string formatedMessage = String.Format("{0,-6}{1}{2}", 
                                               level, 
                                               GetCurrentIndentation(),
                                               message);
        WriteLine(formatedMessage);
    }
    
    /**
     *  Pushes a new LogLayer onto the stack. This will log a message containing
     *  the name of the layer as well as the time that the layer was pushed.
     *  This also increases the indentation level. The push/pop messages for
     *  this layer will be logged at the TRACE level.
     * 
     *  @param name     The name of the LogLayer.
     */
    public void PushTraceLayer(string name) {
        PushLayerWithLogLevel(name, LoggingLevels.TRACE);
    }
    
    /**
     *  Pushes a new LogLayer onto the stack. This will log a message containing
     *  the name of the layer as well as the time that the layer was pushed.
     *  This also increases the indentation level. The push/pop messages for
     *  this layer will be logged at the INFO level.
     * 
     *  @param name     The name of the LogLayer.
     */
    public void PushInfoLayer(string name) {
        PushLayerWithLogLevel(name, LoggingLevels.INFO);
    }
    
    /**
     *  Pushes a new LogLayer onto the stack. This will log a message containing
     *  the name of the layer as well as the time that the layer was pushed.
     *  This also increases the indentation level. The push/pop messages for
     *  this layer will be logged at the DEBUG level.
     * 
     *  @param name     The name of the LogLayer.
     */
    public void PushDebugLayer(string name) {
        PushLayerWithLogLevel(name, LoggingLevels.DEBUG);
    }
    
    /**
     *  Pushes a new LogLayer onto the stack. This will log a message containing
     *  the name of the layer as well as the time that the layer was pushed.
     *  This also increases the indentation level. The push/pop messages for
     *  this layer will be logged at the WARN level.
     * 
     *  @param name     The name of the LogLayer.
     */
    public void PushWarnLayer(string name) {
        PushLayerWithLogLevel(name, LoggingLevels.WARN);
    }
    
    /**
     *  Pushes a new LogLayer onto the stack. This will log a message containing
     *  the name of the layer as well as the time that the layer was pushed.
     *  This also increases the indentation level. The push/pop messages for
     *  this layer will be logged at the WARN level.
     * 
     *  @param name     The name of the LogLayer.
     */
    public void PushErrorLayer(string name) {
        PushLayerWithLogLevel(name, LoggingLevels.ERROR);
    }
    
    /**
     *  Pushes a new LogLayer onto the stack. This will log a message containing
     *  the name of the layer as well as the time that the layer was pushed.
     *  This also increases the indentation level. The push/pop messages for
     *  this layer will be logged at the FATAL level.
     * 
     *  @param name     The name of the LogLayer.
     */
    public void PushFatalLayer(string name) {
        PushLayerWithLogLevel(name, LoggingLevels.FATAL);
    }
    
    /**
     *  Pushes a new LogLayer onto the stack. This will log a message containing
     *  the name of the layer as well as the time that the layer was pushed.
     *  This also increases the indentation level.
     * 
     *  @param name     The name of the LogLayer.
     *  @param level    The level at which to log the push/pop messages.
     */
    private void PushLayerWithLogLevel(string name, LoggingLevels level)
    {
        if (this.LoggingLevel > level) {
            return;
        }
        LogLayer layer = new LogLayer(name, level);
        string startMessage = layer.StartLayer();
        LogWithLevel(layer.logLevel, startMessage);
        stack.Push(layer);
    }

    /**
     *  Pops the most recent TRACE layer off of the stack. This will log a
     *  message containing the name of the layer as well as time elapsed since
     *  the layer was first pushed.
     */
    public void PopTraceLayer() {
        PopLayerWithLogLevel(LoggingLevels.TRACE);
    }
    
    /**
     *  Pops the most recent DEBUG layer off of the stack. This will log a
     *  message containing the name of the layer as well as time elapsed since
     *  the layer was first pushed.
     */
    public void PopDebugLayer() {
        PopLayerWithLogLevel(LoggingLevels.DEBUG);
    }
    
    /**
     *  Pops the most recent INFO layer off of the stack. This will log a
     *  message containing the name of the layer as well as time elapsed since
     *  the layer was first pushed.
     */
    public void PopInfoLayer() {
        PopLayerWithLogLevel(LoggingLevels.INFO);
    }
    
    /**
     *  Pops the most recent WARN layer off of the stack. This will log a
     *  message containing the name of the layer as well as time elapsed since
     *  the layer was first pushed.
     */
    public void PopWarnLayer() {
        PopLayerWithLogLevel(LoggingLevels.WARN);
    }
    
    /**
     *  Pops the most recent ERROR layer off of the stack. This will log a
     *  message containing the name of the layer as well as time elapsed since
     *  the layer was first pushed.
     */
    public void PopErrorLayer() {
        PopLayerWithLogLevel(LoggingLevels.ERROR);
    }
    
    /**
     *  Pops the most recent FATAL layer off of the stack. This will log a
     *  message containing the name of the layer as well as time elapsed since
     *  the layer was first pushed.
     */
    public void PopFatalLayer() {
        PopLayerWithLogLevel(LoggingLevels.FATAL);
    }

    /**
     *  Pops the most recent layer off of the stack. This will log a message
     *  containing the name of the layer as well as time elapsed since the layer
     *  was first pushed.
     */
    private void PopLayerWithLogLevel(LoggingLevels level) {
        if (this.LoggingLevel > level) {
            return;
        }
        if (stack.Count <= 0) {
            LogError("OnionLog: Tried to pop from an empty stack.");
            return;
        }
        LogLayer popped = stack.Pop();
        string endMessage = popped.EndLayer();
        LogWithLevel(popped.logLevel, endMessage);
    }

    /**
     *  Helper method to build a string for the current indentation.
     */
    private string GetCurrentIndentation()
    {
        StringBuilder sb = new StringBuilder();
        for (uint i = 0; i < stack.Count; ++i) {
            sb.Append(indentationString);
        }
        return sb.ToString();
    }
    
    /**
     *  Write a string to the log file.
     */
    private void WriteLine(string s)
    {
		writer.WriteLine(s);
		if (FlushFrequencyInMilliseconds <= 0) {
			writer.Flush();
		} else {
			long unixTimeMilliseconds = 
                (long)(DateTime.Now - BEGINNING_OF_TIME).TotalMilliseconds;
			if ((unixTimeMilliseconds - this.timeOfLastFlush) >= FlushFrequencyInMilliseconds) {
				this.timeOfLastFlush = unixTimeMilliseconds;
				writer.Flush();
			}
		}
    }
    
    /**
     *  Generates default log filename, which is a timestamp:
     *  YYYY-MM-DD-HH.MM.SS
     *  
     *  followed by the file extension ".txt".
     *  e.g. 1991-11-17-11.22.33.txt
     */
    public static string DefaultLogFilename() {
        string timestamp = 
            string.Format("{0}-{1}-{2}-{3}.{4}.{5}",
                          DateTime.Now.Year,
                          DateTime.Now.Month,
                          DateTime.Now.Day,
                          DateTime.Now.Hour,
                          DateTime.Now.Minute,
                          DateTime.Now.Second);
        return (timestamp + ".txt");
    }

	~OnionLogger() {
		writer.Close();
	}

    /**
     *  Each LogLayer represents a new hierarchical organizational level in the
     *  log. Instances of LogLayer are placed on the stack by an OnionLogger.
     */
    private class LogLayer {

       /**
        *   Static initialization block to set the millisecondsPerTick constant.
        */
        static LogLayer() {
            millisecondsPerTick = 1000.0 / (double)Stopwatch.Frequency;
        }
        
        /// The log level associated with this layer.
        public readonly LoggingLevels logLevel;
        
        /// A useful constant for converting from ticks to milliseconds.
        private static double millisecondsPerTick;
        
        /// The name used to identify this LogLayer.
        public readonly string name;

        /// The stopwatch used to keep track of events in this layer.
        private readonly Stopwatch stopwatch;
        
        /**
         *  Instantiate a LogLayer, with the default LoggingLevel INFO.
         *  @param name     The name to identify this LogLayer.
         */     
        public LogLayer(string name)
        {
            this.logLevel = LoggingLevels.INFO;
            this.name = name;
            this.stopwatch = new Stopwatch();
        }
        
        /**
         *  Instantiate a LogLayer.
         *  @param name         The name to identify this LogLayer.
         *  @param loggingLevel The level at which to log the push/pop messages
         *                      for this LogLayer.
         */   
        public LogLayer(string name, LoggingLevels loggingLevel)
        {
            this.logLevel = loggingLevel;
            this.name = name;
            this.stopwatch = new Stopwatch();
        }

        /**
         *  Starts this layer. This should be called just before pushing the
         *  LogLayer object onto the stack.
         * 
         *  @return a string with the name of the LogLayer and the Date & Time
         *  that it was started.
         */ 
        public string StartLayer()
        {
            stopwatch.Start();
            return string.Format("{0} started at {1}", this.name, DateTime.Now);
        }

        /**
         *  Ends this layer. This should be called just after popping the
         *  LogLayer object off of the stack.
         * 
         *  @return a string with the name of the LogLayer and the elapsed
         *  time (in ms) since it was started.
         */ 
        public string EndLayer()
        {
            stopwatch.Stop();
            double ms = millisecondsPerTick * (double)stopwatch.ElapsedTicks;
            return string.Format("{0} ended after {1}ms", this.name, ms);
        }
    }
}


